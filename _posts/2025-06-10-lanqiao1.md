---
title: "蓝桥杯省赛备赛题目 递归与递推"
date: 2025-06-10
categories: [学习]
tags: [C++, 算法,算法备赛]
---

## 递归与递推

### - 1汉诺塔-递归

汉诺塔

### 题目描述

汉诺塔是一个古老的数学问题： 　　有三根杆子 A*A*，B*B*，C*C*。A*A* 杆上有 N*N* 个 (N>1)(*N*>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C*C* 杆：

- 每次只能移动一个圆盘
- 大盘不能叠在小盘上面

提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。问：如何移？最少要移动多少次？

### 输入描述

一行，包含 22 个正整数，一个是 N*N*，表示要移动的盘子数；一个是 M*M*，表示最少移动步数的第 M*M* 步。

### 输出描述

共 22 行。

第一行输出格式为：`#No: a->b`，表示第 M*M* 步骤具体移动方法，其中 No*N**o* 表示第 M*M* 步移动的盘子的编号（N*N*个盘子从上到下依次编号为 11 到 n*n*），表示第M*M*步是将 No*N**o* 号盘子从 a*a* 杆移动到 b*b* 杆（a*a*和 b*b* 的取值均为 {A*A*、B*B*、C*C*}）。

第 22 行输出一个整数，表示最少移动步数。

### 输入输出样例

#### 示例 1

> 输入

```txt
3 2
```

> 输出

```txt
#2: A->B
7
```

### 运行限制

| 语言    | 最大运行时间 | 最大运行内存 |
| ------- | ------------ | ------------ |
| C++     | 1s           | 128M         |
| C       | 1s           | 128M         |
| Python3 | 1s           | 128M         |
| Java    | 1s           | 128M         |

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt,n,m;
void hanoi(string A,string B,string C,int n){

  if(n==1){
    cnt++;
    if(cnt==m)cout<<'#'<<n<<": "<<A<<"->"<<C<<'\n';

  }else{
    hanoi(A,C,B,n-1);
    cnt++;
    if(cnt==m){
      cout<<'#'<<n<<": "<<A<<"->"<<C<<'\n';

    }
    hanoi(B,A,C,n-1);
  }


}

int main(){
  cin>>n>>m;
  hanoi("A","B","C",n);
  cout<<cnt;
  return 0;
}
```

### -2【真题】全排列的价值-递推

全排列的价值

### 问题描述

对于一个排列 A=(a1,a2,⋯,an)*A*=(*a*1,*a*2,⋯,*a**n*), 定义价值 ci 为 a1*a*1 至 ai−1*a**i*−1 中小于 ai*a**i* 的数 的个数, 即 ci=∣{aj∣j<i,aj<ai}∣。 *c**i*=∣{*a**j*∣*j*<*i*,*a**j*<*a**i*}∣。 

定义 A 的价值为 ∑i=1nci 。

给定 n, 求 1 至 n 的全排列中所有排列的价值之和。

### 输入格式

输入一行包含一个整数 n*n* 。

### 输出格式

输出一行包含一个整数表示答案, 由于所有排列的价值之和可能很大, 请 输出这个数除以 998244353 的余数。

### 样例输入 1

```text
3
```

### 样例输出 1

```text
9
```

### 样例输入 2

```text
2022
```

### 样例输出 2

```text
593300958
```

### 样例说明

1 至 3 构成的所有排列的价值如下:

(1,2,3):0+1+2=3

(1,3,2):0+1+1=2

(2,1,3):0+0+2=2

(2,3,1):0+1+0=1

(3,1,2):0+0+1=1

(3,2,1):0+0+0=0

(1,2,3):0+1+2=3

(1,3,2):0+1+1=2

(2,1,3):0+0+2=2

(2,3,1):0+1+0=1

(3,1,2):0+0+1=1

(3,2,1):0+0+0=0

故总和为 3+2+2+1+1=9 。

### 评测用例规模与约定

对于 40% 的评测用例, n≤20;

对于 70%的评测用例, n≤5000;

对于所有评测用例, 2≤n≤106 。

### 运行限制

| 语言    | 最大运行时间 | 最大运行内存 |
| ------- | ------------ | ------------ |
| C++     | 1s           | 512M         |
| C       | 1s           | 512M         |
| Python3 | 1s           | 512M         |
| Java    | 1s           | 512M         |

```cpp

//若插入一个数字，在之前i-1的最前面f[i-1],则价值增加f[i-1](相当于在累加一遍f[i-1],此时i不贡献价值)
//若插在i-1的第一个数的最后面，因为i肯定比i-1中任意的数大，所以价值增加f[i-1]+(i-1)!((i-1)!指的是原先的排列方式，在此基础上每个式子的价值都要+1，；累计起来就是(i-1)!)
//f[i-1]+2*(i-1)!
//f[i-1]+(i-1)*(i-1)!
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
constexpr int N=1e6+10,MOD=998244353;
ll n,f[N],fact[N],sum[N];


int main(){
  ios::sync_with_stdio(false);
  cin>>n;
  fact[0]=1;
  for(int i=1;i<=n;i++){
    f[i]=(f[i-1]*i+fact[i-1]*sum[i-1])%MOD;
    fact[i]=fact[i-1]*i%MOD;
    sum[i]=(sum[i-1]+i)%MOD;
  }
  cout<<f[n];

  return 0;
}
```

### -3奇妙变换-递归

### 问题描述

小蓝面临一个数学问题：定义一个函数 f(x)*f*(*x*) 如下：f(x)={2×x×f(x−6)(x>10)x×(x−1)(x≤10)*f*(*x*)={2×*x*×*f*(*x*−6)(*x*>10)*x*×(*x*−1)(*x*≤10)

现在给定一个整数 n*n*，小蓝想知道 f(n)*f*(*n*) 对 998244353998244353 取模的结果。

### 输入格式

输入包含一个整数 n*n*，表示函数 f*f* 的参数。

### 输出格式

输出一个整数，表示 f(n)*f*(*n*) 对 998244353998244353 取模的结果。

### 样例输入

```
15
```

### 样例输出

```
2160
```

### 评测数据范围

1≤n≤1051≤*n*≤105。

### 运行限制

| 语言    | 最大运行时间 | 最大运行内存 |
| ------- | ------------ | ------------ |
| C++     | 2s           | 256M         |
| C       | 2s           | 256M         |
| Java    | 3s           | 256M         |
| Python3 | 4s           | 256M         |

```cpp
#include<bits/stdc++.h>


using namespace std;

typedef long long ll;
int n;
constexpr ll MOD=998244353,N=1e5+10;
//ll f[N];

ll f(int x){
  if(x<=10)return 1ll*x*(x-1)%MOD;
  return 2ll*x*f(x-6)%MOD;

}

int main(){
  cin>>n;
  ll ans=f(n)%MOD;
  cout<<ans;
  return 0;
}
```

### -4高塔登顶方案-递推

### 问题描述

在蓝桥学院有一座破败的高塔，已经存在了上千年，令人惊奇的是里面有电梯。因为破败的原因，电梯只剩下了中间的按键，范围是 m,k*m*,*k*，也就是每一次可以上升 m,m+1,m+2,…,k*m*,*m*+1,*m*+2,…,*k* 层，高塔非常高，一共有 n*n* 层。爱思考的小乐想知道有多少种不同的方式登上高塔的最高层，但是很可惜他并不会计算，于是请教了脑力担当的你。由于数据非常大，你告诉小乐他也不知道是多少，所以请你把结果对 109+7109+7 取模。

### 输入格式

共一行三个正整数 n,m,k，n表示高塔的高度为 n层， m表示电梯每一次最少上升 m层，k表示电梯每一次最多上升 k 层。

数据范围保证：1≤m≤k≤n≤105。

### 输出格式

输出仅一行，包含一个正整数，表示登上高塔方案数对 109+7109+7 取模的结果。

### 样例输入1

```text
5 1 2
```

### 样例输出1

```text
5
```

### 样例输入2

```text
5 3 3
```

### 样例输出2

```text
0
```

### 样例说明

对于样例 11：

1+1+1+1+1=5

1+1+1+2=5

1+1+2+1=5

1+2+1+1=5

1+2+2=5

### 运行限制

| 语言    | 最大运行时间 | 最大运行内存 |
| ------- | ------------ | ------------ |
| C++     | 1s           | 256M         |
| C       | 1s           | 256M         |
| Java    | 2s           | 256M         |
| Python3 | 3s           | 256M         |

```cpp
#include<bits/stdc++.h>

using namespace std;
int n,m,k;
constexpr int N=1e5+10,mod=1e9+7;
typedef long long ll;
ll f[N],s[N];
//int f[N],s[N];

int main(){
  ios::sync_with_stdio(false);
  cin>>n>>m>>k;
  f[1]=1,s[1]=1;
  int a=0;
  for(int i=2;i<=n;i++){
    /*for(int j=m;j<=k;j++){
      f[i]+=f[i-j];
      f[i]%=mod;
    }*/
    int l=max(a,i-k);//减去最多的得到左边界
    int r=max(a,i-m);//
    f[i]=(s[r]-s[l-1]+mod)%mod;
    s[i]=(s[i-1]+f[i])%mod;

  }
  cout<<f[n];
  return 0;
}
```

### - 5【真题】数正方形

数正方形

### 题目描述

在一个 N×N*N*×*N* 的点阵上，取其中 4 个点恰好组成一个正方形的 4 个顶点，一共有多少种不同的取法？

由于结果可能非常大，你只需要输出模 109+7109+7 的余数。

![img](https://doc.shiyanlou.com/courses/uid1580206-20210202-1612250926303)

如上图所示的正方形都是合法的。

### 输入描述

输入包含一个整数 N (2≤N≤106)*N* (2≤*N*≤106)。

### 输出描述

输出一个整数代表答案。

### 输入输出样例

#### 示例

> 输入

```txt
4
```

> 输出

```txt
20
```

### 运行限制

| 语言    | 最大运行时间 | 最大运行内存 |
| ------- | ------------ | ------------ |
| C++     | 1s           | 256M         |
| C       | 1s           | 256M         |
| Python3 | 1s           | 256M         |
| Java    | 1s           | 256M         |

```cpp
#include<bits/stdc++.h>
using namespace std;


int n;
typedef long long ll;
constexpr int MOD=1e9+7;
/*
int solve(int n){
  n--;
  int ans=1;
  int f=1;//平方
  for(int i=2;i<=n;i++){//因为边长为1时不存在斜着的正方形，故ans初始化为1开始，后续通过2处理
    f+=1ll*i*i%MOD;//求正的正方形
    f%=MOD;
    ans=(ans+f)%MOD;
  }
  return ans;
}
*/
ll solve(int n){
  
  ll ans=0;
  for(int i=1;i<n;i++){
    ans+=1ll*i*(n-i)*(n-i);
    ans=ans%MOD;
  }
  return ans;
}

int main(){
  cin>>n;
  cout<<solve(n);

  return 0;
}
```

